use byteorder::{LittleEndian, ReadBytesExt};
use console_error_panic_hook;
use ff::PrimeField;
use libspartan::{Assignment, Instance, NIZKGens, NIZK};
use merlin::Transcript;
use pasta_curves::group::Group;
use serde_wasm_bindgen;
use std::io::{Error, Read};
use wasm_bindgen::prelude::*;
use web_sys;

pub type G1 = pasta_curves::pallas::Point;
pub type F1 = <G1 as Group>::Scalar;

// A macro to provide `println!(..)`-style syntax for `console.log` logging.
macro_rules! log {
  ( $( $t:tt )* ) => {
      web_sys::console::log_1(&format!( $( $t )* ).into());
  }
}

#[cfg(target_family = "wasm")]
pub use wasm_bindgen_rayon::init_thread_pool;

#[wasm_bindgen]
pub fn init_panic_hook() {
    console_error_panic_hook::set_once();
}

#[wasm_bindgen]
pub fn prove_poseidon(circuit: JsValue, vars: &[u8]) -> Result<JsValue, JsValue> {
    web_sys::console::time_with_label("load witness");
    let witness = load_witness_from_bin_reader::<F1, _>(vars).unwrap();
    let witness_bytes = witness
        .iter()
        .map(|w| w.to_repr())
        .collect::<Vec<[u8; 32]>>();

    let assignment = Assignment::new(&witness_bytes).unwrap();
    web_sys::console::time_end_with_label("load witness");

    web_sys::console::time_with_label("parse input");
    let circuit: Instance = serde_wasm_bindgen::from_value(circuit).unwrap();
    web_sys::console::time_end_with_label("parse input");

    let num_vars = 626;
    let num_cons = 609;
    let num_inputs = 0;

    web_sys::console::time_with_label("generate public parameters");
    // produce public parameters
    // !Needs to be generated by the verifier
    let gens = NIZKGens::new(num_cons, num_vars, num_inputs);

    web_sys::console::time_end_with_label("generate public parameters");

    let public_input = Assignment::new(&[]).unwrap();

    let mut prover_transcript = Transcript::new(b"nizk_example");

    web_sys::console::time_with_label("prove");
    // produce a proof of satisfiability
    let proof = NIZK::prove(
        &circuit,
        assignment.clone(),
        &public_input,
        &gens,
        &mut prover_transcript,
    );
    web_sys::console::time_end_with_label("prove");

    web_sys::console::time_with_label("verify");

    let mut verifier_transcript = Transcript::new(b"nizk_example");

    proof
        .verify(&circuit, &public_input, &mut verifier_transcript, &gens)
        .unwrap();

    web_sys::console::time_end_with_label("verify");

    Ok(serde_wasm_bindgen::to_value(&proof).unwrap())
}

// Copied from Nova Scotia
fn read_field<R: Read, Fr: PrimeField>(mut reader: R) -> Result<Fr, Error> {
    let mut repr = Fr::zero().to_repr();
    for digit in repr.as_mut().iter_mut() {
        // TODO: may need to reverse order?
        *digit = reader.read_u8()?;
    }
    let fr = Fr::from_repr(repr).unwrap();
    Ok(fr)
}

fn load_witness_from_bin_reader<Fr: PrimeField, R: Read>(mut reader: R) -> Result<Vec<Fr>, Error> {
    let mut wtns_header = [0u8; 4];
    reader.read_exact(&mut wtns_header)?;
    if wtns_header != [119, 116, 110, 115] {
        // ruby -e 'p "wtns".bytes' => [119, 116, 110, 115]
        panic!("invalid file header");
    }
    let version = reader.read_u32::<LittleEndian>()?;
    // println!("wtns version {}", version);
    if version > 2 {
        panic!("unsupported file version");
    }
    let num_sections = reader.read_u32::<LittleEndian>()?;
    if num_sections != 2 {
        panic!("invalid num sections");
    }
    // read the first section
    let sec_type = reader.read_u32::<LittleEndian>()?;
    if sec_type != 1 {
        panic!("invalid section type");
    }
    let sec_size = reader.read_u64::<LittleEndian>()?;
    if sec_size != 4 + 32 + 4 {
        panic!("invalid section len")
    }
    let field_size = reader.read_u32::<LittleEndian>()?;
    if field_size != 32 {
        panic!("invalid field byte size");
    }
    let mut prime = vec![0u8; field_size as usize];
    reader.read_exact(&mut prime)?;
    // if prime != hex!("010000f093f5e1439170b97948e833285d588181b64550b829a031e1724e6430") {
    //     bail!("invalid curve prime {:?}", prime);
    // }
    let witness_len = reader.read_u32::<LittleEndian>()?;
    // println!("witness len {}", witness_len);
    let sec_type = reader.read_u32::<LittleEndian>()?;
    if sec_type != 2 {
        panic!("invalid section type");
    }
    let sec_size = reader.read_u64::<LittleEndian>()?;
    if sec_size != (witness_len * field_size) as u64 {
        panic!("invalid witness section size {}", sec_size);
    }
    let mut result = Vec::with_capacity(witness_len as usize);
    for _ in 0..witness_len {
        result.push(read_field::<&mut R, Fr>(&mut reader)?);
    }
    Ok(result)
}
